# 🗺️ 문다인 포트폴리오
>   Unity, C#을 이용한 게임, 프로그램, 모바일 앱 개발의 경험이 있습니다. <br>일상에서도 항상 개발에 대한 아이디어를 떠올립니다. <br>어떤 일이든 효율적인 방법을 끊임없이 모색하고 자동화하는 것에 관심이 있습니다. <br><br>팀 프로젝트를 진행할 때는 타인의 코드에 대한 이해가 빠른 편이며, 소통할 때 상대의 의도를 잘 파악합니다. <br>책임감이 있어, 한 번 시작한 일은 끝까지 몰두합니다.
 <br><br> 유저가 사용하기 편하고, 설명을 꼼꼼하게 읽지 않아도 사용법을 금방 익힐 수 있는 인터페이스를 중시합니다. <br>누구나 쉽게 다가갈 수 있는 게임을 만드는 것이 목표입니다.
<br/>
<br>



## 🎮 쿡앤몬스터: 할머니의 레시피

이븐아이 게임톤 (2025.07.14 ~) 참가작 

<br>

<img align='right' width="280" height="350" alt="Image" src="https://github.com/user-attachments/assets/a389c605-a18d-401a-b6d8-effd858e0bee" />

- **2차 내부 테스트용 프로토타입** : 
<br>

- **장르** : 요리 + 전투 + 경영 시뮬레이션

- **개발 기간** : 2025.07.28 ~ 진행 중 

- **개발 인원** : 8명 (기획 3, 사업PM 1, 개발PM 1, 프로그래머 2, QA 1) - <ins>프로그래머</ins>로 참여

- **플랫폼** : Android (Google Play 비공개 테스트 중)

- **개발 환경**

  - **언어** : C#
  - **엔진** : Unity

    <br/><br/>
    
## 🧩 게임 개요

### 📝 게임 소개

`쿡앤몬스터 : 할머니의 레시피`는 **전투로 재료를 수집하고, <br>요리를 제작하여 손님에게 판매하는 과정을 반복하며 성장하는 경영 시뮬레이션 게임**입니다.<br>
플레이어는 요리로 얻은 수익과 레시피 해금으로 **점차 확장된 메뉴와 전략**을 펼치게 되며, <br>전투/경영/수집 요소가 결합된 **하이브리드 플레이**를 목표로 합니다.

<br>

### 📖 스토리

지구의 작은 도시에서 레스토랑을 운영하던 요리사 **프티**.<br> 
그녀의 보물은 할머니가 남긴 낡은 레시피북이었습니다.<br> 
어느 날, 퇴근길에 하늘에서 내려온 빛 속에서 외계인 **제피르**가 나타나 전합니다.<br> 

“다크 스파이스라는 물질이 은하 전역에 퍼지면서 모든 음식 재료들이 몬스터로 변해버렸습니다.<br> 
하지만 당신의 할머니가 남긴 특별한 능력과 레시피북이 이 저주를 풀 수 있는 유일한 열쇠일지도 모릅니다!”<br> 

이에 프티는 행성마다 저주받은 재료 몬스터를 쓰러뜨리고, 특별한 요리로 저주를 해제하며 **은하계의 평화를 되찾기 위한 여정**을 시작합니다.<br> 

<br>

### 🎯 핵심 특징

- **전투와 요리의 결합**: 몬스터를 쓰러뜨려 재료를 수집하고, 조리도구를 사용해 다양한 요리를 제작합니다.
- **손님 시스템**: 손님의 주문에 따라 요리를 판매하고 보상을 얻으며 성장합니다.
- **순환 구조**: 전투 → 재료 획득 → 요리 제작 → 판매 → 성장으로 이어지는 플레이 루프를 형성합니다.
- **전략적 확장**: 레시피 해금과 선택을 통해 점차 메뉴를 넓히고, 플레이 스타일을 다양하게 발전시킬 수 있습니다.

<br/><br/>

## 🔨 주요 개발 역할

### 🧑🏻‍🍳 요리 시스템 구현

> ### 🎓 튜토리얼 UI 및 상호작용

- 신규 플레이어가 게임의 핵심 루프를 쉽게 이해할 수 있도록 **튜토리얼 UI**를 제작했음.
- 기본 조작(이동·상호작용) → 재료 획득 → 요리 제작 → 손님 판매 순으로 **직관적인 안내 흐름**을 제공했음.
- 그 외 재료를 수급할 수 있는 전투 위치 및 체력 회복 방법 등을 적절한 타이밍에 안내함.
- 단순 텍스트 설명이 아니라 **상호작용 기반 단계 진행**으로 구성해 몰입감을 높였음.

<br>

> ### **🎒 재료 관리 및 인벤토리**

- 플레이어가 재료를 획득하면 **인벤토리에 자동 저장**되도록 했음.
- 인벤토리는 **아이콘 + 개수**로 표시되며, 동일 재료는 **슬롯 병합**했음.
- **가방 버튼**으로 인벤토리를 **접었다/펼쳤다** 할 수 있게 했고, 
창이 열려 있어도 **실시간 반영**되도록 했음(획득·소비 즉시 업데이트).

<br>

> ### **📖 레시피 가능 여부 표시**

- 재료를 얻을 때마다 **보유 재료로 제작 가능한 레시피**를 판별해 **가능/불가 상태**를 표시했음.
- 제작 가능할 경우에는 **현재 보유 재료로 레시피 당 몇 개까지 제작 가능한지도 함께 표시**했음.
- 인벤토리·레시피 UI 양쪽에서 상태가 **동기화**되도록 이벤트로 연결했음.

<br>

> ### **🍳 조리대/도구 상호작용 & 제작 흐름**

- 특정 **조리도구**(예: 프라이팬, 냄비 등)에 다가가면 **요리 선택창**이 뜨도록 했음.
- 요리 선택창에는 **해당 도구로 만들 수 있는 레시피만 필터링**해 노출했음.
- 레시피 버튼을 누르면 **확인 창**에 **요리 이름 + 필요 재료 목록**을 표시함.
    - **재료 부족**이면 즉시 **부족 메시지**를 노출하고 취소됨.
    - **재료 충분**이면 제작이 시작되며, 필요한 재료가 **즉시 차감**됨.
- 제작이 완료되면 **완료 표시**(게이지 바 색 변경/완성 레시피 말풍선)가 뜨도록 했음.
- 플레이어는 완료 표시를 확인하고 **완성된 요리를 수령**할 수 있음(중복 수령 방지 처리 포함).

<br>

> ### 🛠️ 준비 단계 레시피 관련 구현

- **레시피 구매 및 해금 기능**
    - 스테이지 시작 전, 현재 보유한 레시피 목록을 UI로 확인할 수 있음.
    - 챕터마다 해금 가능한 레시피가 열리며, 열릴 때마다 안내 메시지가 뜨도록 함
    - 해금된 레시피(판매가격 순) → 해금 가능한 레시피(구매가격 순) 순으로 정렬해서 보여주며, 투명도를 조절하여 해금 여부를 알 수 있도록 함.
    - 레시피마다 세부 정보를 볼 수 있고, 해금되지 않은 레시피는 구매를 통해 해금할 수 있도록 구현함
- **레시피 선택(메뉴판) 기능**
    - 다음 스테이지에서 사용할 **레시피 3개를 선택**할 수 있음.
    - 선택한 레시피에 따라 해당 요리에 필요한 재료를 드롭하는 **몬스터만 등장**하도록 구현함.

<br>

> ### 🍽️ 작업대 상호작용 확장

- 모든 작업대에서 **음식을 올려놓거나 들 수 있는 기능**을 구현했음.
- 불필요하거나 잘못 올린 음식은 **쓰레기통에 버릴 수 있는 기능**을 추가해 
인벤토리·작업대 정리가 가능하도록 했음.

<br>

> ### **💰 판매 및 자동화 전환**

- **해당 요리를 주문한 손님이 있는 판매대 접촉 시 자동 판매**되도록 구현함(TriggerManager 기반 이벤트 처리로 누락/중복 방지).
    - 초기에는 플레이어가 요리를 들고 **손님에게 가서 인터렉션 버튼을 눌러야** 판매되도록 했으나 이후 기획 변경에 맞춰 확장
- 판매 시 **가격·보상**이 즉시 반영되고, 손님은 음식 수령 후 **퇴장**하도록 했음.

<br>

> ### **🖼️ UI 연동 및 가시성**

- 손님 근접 시 **요청 레시피 정보**가 표시되도록 했음(현재 목표를 직관적으로 제시).
- 인벤토리 변화, 조리 진행/완료, 판매 결과가 **이벤트 기반으로 UI에 즉시 갱신**되도록 했음.
- 버튼 내부 구성(텍스트·아이콘·가격)은 **가변 길이**에 맞춰 자동 정렬되도록 했음.

<br>

> ### **🔧 확장성 고려**

- 제작/판매/손님 시스템을 **이벤트 중심 구조**로 연결해, 추후 **정비(레시피 구매·선택)**, **스토리/튜토리얼** 등 기능이 계속 추가되어도 쉽게 연동 가능하게 했음.

<br/><br/>

## 🙋 손님 시스템 구현

> ### **🚶 스폰 & 동선 관리**

- **대기열 최대 4명** 기준으로 손님을 관리했음.
- 시작은 **랜덤 자리 배치**로 스폰하고, 이후에는 **빈 자리를 우선 채우는 방식**으로 유지했음.
- 손님이 퇴장하면 해당 자리로 **다음 손님을 즉시 이동/스폰**하도록 했음.
- 경로는 **StartPoint → OrderPoint(수령 지점) → ExitPoint** 순으로 단순화했음.

<br>

> ### **🧠 상태 관리**

- 손님은 `대기 → 주문 표시 → 판매/수령 → 퇴장` 단계를 거침.
- 각 단계 전환 시 이벤트를 발행해 요리 시스템 및 전체 UI와 연결되도록 했음.

<br>

> ### **🧾 주문 생성 & 표시**

- 스폰 시 **요청 레시피**를 부여했고, 플레이어가 근접하면 **주문 UI가 표시**되도록 했음.
- 주문 정보는 **레시피 이름 + 필요 재료 + 가격**으로 묶어 UI에 노출했음.

<br>

> ### **⚡ 자동 판매 연동**

- 플레이어가 완성 음식을 들고 손님과 접촉하면 **즉시 판매 처리**가 되도록 했음.
- 음식이 없거나 다른 음식을 들고 있을 경우 **아무 일도 일어나지 않음**.
- 같은 음식을 들고 접촉했을 때만 판매가 일어나고, 손님은 음식을 받고 퇴장함.
- 즉, 급할 땐 플레이어가 **음식을 들고 손님에게 부딪히기만 해도 판매가 이뤄지는 구조**로 설계했음.

<br>

> ### **♻️ 풀링 & 성능**

- 손님 프리팹을 **오브젝트 풀링**으로 관리해 Instantiate/Destroy 사용을 줄였음.
- 스폰 시 **외형을 랜덤화**해 반복감을 줄였음.

<br>

> ### **🖼️ UI 연동**

- 손님 수, 대기열, 주문 정보가 **이벤트 기반으로 UI에 반영**되도록 했음.
- 판매가 일어나면 보상 값이 즉시 갱신되어 게임 전체 루프가 이어지도록 했음.

<br><br/>

## 🎨 화면 및 리소스 구성

> ### 🖼️ UI

- 화면을 **Top Bar / Bottom Bar / Right Area** 등 영역별로 나눠 UI를 제작했음.
- **반응형 UI**를 적용해 다양한 기기 해상도와 비율에서도 레이아웃이 깨지지 않도록 했음.
- 기기별 **Safe Area**(노치, 하단 제스처 바 등)를 고려해 UI가 잘리지 않도록 보정했음.
- 버튼 내부에 `[레시피 구매] [코인 아이콘] [가격]`처럼 **가변 텍스트와 아이콘이 함께 들어가는 경우**에도 정렬이 어긋나지 않도록 `LayoutGroup`과 `ContentSizeFitter`를 조합해 구현했음.
- UI가 다른 영역을 침범하는 경우에는 **스케일과 위치를 조정**해 안정적으로 표시되도록 했음.
- 스토리의 경우 몰입도를 높이기 위해 컷신·대화 UI가 모든 기기에서 적절하게 배치되도록 반응형 UI로 작업함

<br>

> ### 🗺️ 타일맵

- **기지 맵과 전투 맵**을 타일맵으로 구성했음.
- PPU와 스프라이트 크기가 서로 다른 에셋을 통일해 배치했고, **충돌 범위**도 함께 조정했음.
- 타일맵 기반으로 배치한 오브젝트와 별도의 스프라이트 오브젝트를 혼합해, 배경과 상호작용 오브젝트를 효율적으로 분리했음.

<br>

> ### 🐾 에셋 가공

- 상업용으로 구매한 몬스터 에셋들이 **크기·피벗·여백**이 제각각이라, 충돌 범위가 들쭉날쭉했음.
- **스프라이트 에디터**에서 프레임별 윤곽선을 직접 따서 **정확한 Physics Shape**을 만들었음.
- 이후, 콜라이더 크기를 자동으로 보정하기 위해 **콜라이더 축소 스크립트**를 작성했음.
    - 스크립트는 원본 Physics Shape 데이터를 불러와, 각 꼭짓점 좌표를 일정 비율 안쪽으로 이동시켜 **실루엣보다 살짝 작은 콜라이더**를 생성함.
    - 이로써 몬스터 외형의 빈 공간이나 미세한 투명 픽셀 때문에 생기던 **헛충돌 문제**를 줄였음.
- 애니메이션 전환 시 프레임마다 저장된 콜라이더 데이터를 불러와 적용해, **프레임 간 충돌 경계 불일치 문제**를 해결했음.

<br/><br/>

## 🗂 데이터 관리 자동화 적용

> ### 📥 외부 툴 도입

- 원본 데이터는 **엑셀**로 관리했음. (수정하면 안 되는 컬럼의 경우 셀 보호로 잠금)
- 외부 툴을 통해 엑셀 데이터를 → **JSON 변환**, **enum 스크립트**, **로더 스크립트**까지 자동 생성되도록 했음.
- 이 과정에서 직접 JSON을 만들거나 코드를 수정할 필요 없이, **툴 실행만으로 자동 반영**되게 했음.

<br>

> ### 🔗 프로젝트 워크플로 연결

- 변환된 JSON과 코드 파일이 **유니티 프로젝트에 즉시 반영**되도록 폴더 구조와 경로를 정리했음.
- “엑셀 수정 → 툴 실행 → 유니티 반영” 절차를 표준화해 **팀원 누구나 같은 방식으로 사용할 수 있게** 했음.

<br>

> ### 📘 안정화

- 경로 오류, 데이터 누락 같은 문제를 미리 점검하고, 직접적으로 데이터를 수정하지 못하도록 권한 관리 및 데이터 수정 시 바로 공유하여 데이터 동기화 문제가 발생하지 않도록 조치함.
- **사용법을 화면 공유를 통해 설명**하여 안정성 있게 사용하도록 했음.

<br>

> ### ✅ 결과

- 데이터 변경 시 수동 반영 과정이 사라져 **작업 효율이 크게 올라갔음**.
- JSON·코드 자동화로 **오타, 형식 오류, 누락**이 줄어들어 안정성이 확보됨.
- 기획 변경(레시피 추가/수정)에도 **데이터와 코드가 항상 동기화**되도록 유지할 수 있었음.

<br><br/>

## 🔮 추후 개발 예정 기능

> ### 🏪 상점 시스템 구현 (+ 광고 및 인앱 결제 구현)

- 게임 내 재화·아이템 구매가 가능한 상점 시스템을 구축할 예정임.
- Google Play 결제 및 보상형 광고를 연동해 실제 서비스 환경에서 동작 가능하게 확장할 예정임.

<br/><br/>

## 🛠️ 문제 해결 경험

### 🍳 자동 판매 전환에 따른 트리거·이벤트 동기화 문제

### ⚙️ **문제 상황**

초기엔 `OnTriggerEnter/Exit` + **인터랙션 버튼**을 눌러야만 동작하도록 했음.

기획이 **접촉 즉시 판매(자동 판매)**로 바뀌면서, 접촉 시점마다 **필요 정보 조회/처리**가 일어나야 했고,

가격·재고 등 **변동 정보가 화면에도 바로 보여**야 했음.

기존 구조에선 버튼 전제 로직 때문에 처리 타이밍이 어긋나거나 누락되는 문제가 있었음.

### 🧩 **원인 분석**

- 트리거 콜백 안에서 바로 업무 로직을 처리해 **물리 이벤트와 도메인 로직이 뒤섞였음**.
- 버튼 입력을 전제로 짰던 흐름이라 **접촉만으로 처리해야 할 시나리오가 누락**되었음.
- 접촉 중 값을 갱신하려고 `Stay`/매 프레임 확인을 쓰면 **중복 호출**이 생길 수 있었음.

### 🛠️ **해결 방법**

- **구조 분리**: `TriggerManager – PlaceTrigger – TriggerZone – Listener`로 역할을 분리했음.
    - **TriggerZone**: 물리 이벤트만 감지(`Enter/Exit`). 처리 로직 없음.
    - **TriggerManager**: 현재 **접촉 중인 대상 목록**을 관리하고, 이벤트를 **한 곳에서** 발행함.
    - **PlaceTrigger**: 해당 지점의 메타정보(종류/ID/가격 소스 등)를 보관하고, **값이 바뀔 때만** “변경됨” 이벤트를 쏘게 했음.
    - **Listener(UI/시스템)**: 매 프레임 확인 없이 **구독 방식**으로 갱신을 받아 화면·로직에 반영했음.
- **처리 흐름 단순화**
    1. `Enter` 시점에 자동 판매가 필요한 트리거면 **즉시 1회 처리**했음.
    2. 접촉이 유지되는 동안 가격/재고가 **실제로 변경될 때에만** PlaceTrigger가 이벤트를 발행했고, UI가 이를 받아 **표시만 갱신**했음.
    3. `Exit` 시점에는 목록에서 제거하여 이후 이벤트가 가지 않도록 했음.
- **프레임 루프 의존 제거**: `OnTriggerStay`나 매 프레임 폴링을 없애고, **변경 시 알림**만 처리했음.

### 🔁 **결과**

- 자동 판매로 바뀐 뒤에도 **중복 실행/누락 없이** 안정적으로 처리됨.
- UI는 **값이 실제로 바뀔 때만** 갱신되어 보기 자연스러워졌음.
- 물리 감지(TriggerZone)와 업무 처리(TriggerManager/PlaceTrigger/Listener)가 분리되어 **읽기·확장·디버깅이 쉬워졌음**.

<br/><br/>

### 📱 반응형 UI 배치 및 Stretch 적용 문제

### ⚙️ **문제 상황**

- 다양한 기기 해상도(16:9, 19.5:9, 태블릿, Z Fold 등)에서 UI를 테스트했을 때,
    - **같은 그룹에 붙어 있어야 할 버튼들이 기기 너비 변화에 따라 따로따로 떨어져 보이는 현상**이 발생했음.
    - 예를 들어, 조이스틱과 푸시 버튼처럼 항상 같이 붙어 있어야 하는 묶음이 화면 비율에 따라 서로 간격이 달라져 UI가 어색하게 배치되었음.

### 🧩 **원인 분석**

- 노치, 하단바 같은 **SafeArea는 고려해서 보정**했음.
- 하지만 전체 화면에 **Stretch를 일괄 적용해 위치를 맞추는 방식**만 사용하다 보니,
    - 기기 너비가 변할 때 **UI 요소 간 상대적인 간격 유지**를 적용하지 못했음.
    - 그 결과, 같이 붙어 있어야 하는 버튼들이 함께 관리되지 않는 문제가 발생했음.

### 🛠️ **해결 방법**

1. **UI 영역 구분**
    - 화면을 **Top Bar / Bottom Bar / Right Area** 등으로 나누어 그룹 단위로 정렬을 유지하도록 함.
    - 각 영역 안에서만 Stretch를 적용하고, 영역 간에는 상호 침범하지 않도록 함.
2. **LayoutGroup 활용**
    - 버튼이나 텍스트+아이콘 같은 묶음은 `Horizontal/Vertical LayoutGroup`으로 관리해,
        
        기기 너비가 변해도 **항상 일정한 간격과 정렬**을 유지하도록 했음.
        
3. **버튼 내부 정렬 개선**
    - `[레시피 구매] [코인 아이콘] [가격 텍스트]` 같은 UI는 `ContentSizeFitter`와 `LayoutGroup`을 조합해, 가격 길이가 달라져도 **정렬이 깨지지 않게 자동 보정**되도록 구현했음.
        
        

### 🔁 **결과**

- 다양한 화면 비율·해상도에서 UI 간격과 묶음이 안정적으로 유지됨.
- SafeArea 고려 + Stretch 조정의 한계를 보완해 **가독성과 일관성**이 확보됨.
- 영역 단위로 UI를 관리하게 되어 **추가 화면 제작 속도도 향상**됨.

  
<br/><br/>

### 🐾 몬스터 에셋 가공(콜라이더 정합) 문제

### ⚙️ **문제 상황**

- 상업용 에셋을 여러 곳에서 구매하여, 에셋마다 **픽셀 크기·비율·피벗 기준**이 제각각이라, 같은 월드 스케일에서 **콜라이더가 너무 크거나 작게 맞는 문제**가 발생했음.
- 애니메이션 전환 시 프레임마다 외형이 달라 **충돌 경계가 들쭉날쭉**해 보이는 현상도 있었음.

### 🧩 **원인 분석**

- 에셋 제공처별로 **PPU, Pivot, Trim 여부**가 달라 물리 경계가 통일되지 않았음.
- 자동 생성(Box/Auto) 콜라이더는 투명 여백과 비정형 윤곽을 제대로 반영하지 못해 **빈 공간까지 충돌**하는 경우가 있었음.
- 애니메이션 클립이 프레임마다 실루엣이 달라지는데, **정적 콜라이더**만 사용하면 프레임 간 오차가 누적됐음.

### 🛠️ **해결 방법**

1. **가져오기 표준화**
    - 몬스터류 공통 **PPU(예: 세로 기준 통일)**, **Pivot 규칙(바닥 중앙)**을 정해 일괄 적용했음.
    - 불필요한 여백 제거(Trim) 규칙을 정해 시각/물리 기준을 맞췄음.
2. **스프라이트 에디터 기반 윤곽 추출**
    - Sprite Editor에서 모든 프레임의 **Outline/Physics Shape**를 직접 따서, **실루엣에 맞는 폴리곤**을 확보했음.
    - 프레임별 물리 경계를 에셋에 저장해 애니메이션 전환 시 **정확한 충돌 모양**을 사용하도록 했음.
3. **콜라이더 인셋(안쪽 수축) 적용**
    - 추출한 폴리곤을 **일정 마진만큼 안쪽으로 축소**하는 로직을 적용했음(가시 영역보다 살짝 작은 충돌 경계).
    - 결과적으로 가장자리 픽셀의 미세 요철/투명 픽셀로 인한 **헛충돌을 방지**했음.
4. **런타임 동기화**
    - 스프라이트가 프레임 전환될 때 해당 프레임의 **저장된 폴리곤**을 불러와 콜라이더에 즉시 반영하도록 했음.
    - 필요 시만 갱신(스프라이트 변경 시)하여 **성능 부담 최소화**했음.

### 🔁 **결과**

- 서로 다른 출처의 에셋이라도 **통일된 PPU·Pivot·Trim 규칙**으로 크기/충돌감이 일관되게 맞춰졌음.
- 실루엣 기반 폴리곤 + 인셋 적용으로 **빈 공간 판정·과충돌이 사라짐**.
- 애니메이션 전환 시에도 프레임별 충돌이 **자연스럽게 이어져** 타격감·피격감이 안정됨.

<br/><br/>

### 🚧 기지–전투 맵 바리게이트 문제

### ⚙️ **문제 상황**

- 기지와 전투 맵 사이의 바리게이트는
    - 플레이어가 **접시를 들고 있을 때는 밖으로 못 나가게** 하고,
    - 몬스터는 **기지 안으로 못 들어오게** 막아야 했음.
- 처음에는 하나의 콜라이더에서 `isTrigger` 값을 켜고 끄는 방식으로 구현했는데,
    - 트리거가 불안정하게 동작해 이벤트가 누락되거나,
    - 통과하면 안 되는 경우에도 그냥 지나가는 문제가 발생했음.

### 🧩 **원인 분석**

- 트리거와 벽 역할을 한 오브젝트에서 동시에 처리하려다 보니 **충돌 판정이 꼬임**.
- `isTrigger`를 켜고 끄는 방식은 상황에 따라 이벤트가 중복되거나 사라질 수 있었음.

### 🛠️ **해결 방법**

1. **센서와 벽을 역할 분리**
    - 센서는 항상 Trigger 상태로 두고, **플레이어나 몬스터가 접촉했는지 감지만** 하도록 함.
    - 벽은 실제 충돌을 담당하도록 분리했음.
2. **조건에 따라 충돌 무시 처리**
    - 플레이어가 접시를 들고 있을 때만 **플레이어와 벽의 충돌을 유지**하도록 함.
    - 접시를 들고 있지 않으면 `Physics2D.IgnoreCollision`을 사용해 **플레이어와 벽의 충돌을 무시**하도록 변경.
    - 몬스터는 항상 벽과 충돌을 유지하도록 해 기지에 들어오지 못하게 했음.

### 🔁 **결과**

- 접시를 들고 있으면 **기지 밖으로 나갈 수 없고**, 접시가 없을 때만 **자유롭게 이동 가능**해짐.
- 몬스터는 언제나 기지 안으로 들어오지 못하도록 안정적으로 차단됨.
- `isTrigger`를 토글하던 방식 대신, **충돌 무시 설정을 조건부로 적용**해 동작이 단순해지고 안정성이 확보됨.


<br/><br/>


## ✏️ 아쉬웠던 점과 회고

### 1. 프로젝트 정리와 효율화 부족<br>
개발 기간이 짧아 콘텐츠를 크게 확장하지 못한 점도 아쉽지만,<br>
**코드와 프로젝트 전반을 정리하거나 효율적인 방식을 깊게 고민할 시간이 부족했음**.<br>
다음 프로젝트에서는 구현 뿐만 아니라 구조를 정돈하는 시간을 반드시 고려해야겠다고 느꼈음.
<br>

### 2. 구조 설계의 유연성 부족<br>
처음 코드를 작성할 때는 **효율성**을 먼저 고려했음.
하지만 프로젝트를 진행하며 기획 변경(예: 수동 판매 → 자동 판매)으로 인해 구조를 여러 번 바꾸어야 했음.<br>
기획 변경이 잦을 수도 있다는 점을 경험하면서 효율성 못지않게 **확장성과 변경 가능성을 우선 고려**해야 한다는 교훈을 얻었음.
**처음부터 조금 더 효율적인 코드와 변화에 유연하게 대응할 수 있는 구조 중 고민했을 때**<br>
**후자로 설계했다면 수정 부담이 줄었을 것**이라는 점을 깨달았음.<br>
이를 통해 “처음 설계 시점에서 얼마나 확장성과 변경 가능성을 고려할 수 있는가”의 중요성을 배웠음.
<br>
이후에는 구조를 설계할 때 **변화에 대응할 수 있는 여지**를 남겨두는 방향으로 접근하게 되었음.



### 3. 기초 요소에 대한 사전 고려 부족<br>
UI 반응형 대응이나 콜라이더 충돌 처리처럼 기본적이지만 게임 플레이에 직결되는 문제들을 겪으면서, 초기 설계 단계에서 기초 요소를 충분히 고려하는 것의 중요성을 체감했음.
또한 저장 데이터 구조, 이벤트 전달 방식, 오브젝트 풀링 정책 등 프로젝트의 근간을 이루는 시스템 설계를 초기에 더 깊게 고민했다면, 전체 개발 과정이 훨씬 안정적이었을 것이라는 아쉬움이 있었음.
이를 통해 앞으로는 단순히 눈에 보이는 기능 구현뿐만 아니라, 프로젝트 전체의 안정성과 지속 가능성을 뒷받침하는 기초 설계를 더 중점적으로 다뤄야겠다고 생각함.

<br/><br/>

## ✅ 프로젝트에서 얻은 것

- Unity와 C#을 활용해 **요리 제작 → 판매 → 성장**으로 이어지는 게임 루프 전체를 직접 구현하면서, **핵심 플레이를 책임질 수 있는 역량**을 키웠음.
  
- TriggerManager, 이벤트 기반 구조 설계, Collider 보정 스크립트 등 **직접 문제를 분석하고 해결책을 코드로 적용하는 경험**을 할 수 있었음.

- UI 반응형 대응, 인벤토리 관리, 데이터 자동화 등 **실제 서비스에 필요한 기술적 요소**를 학습하고 적용했음.
 
- 협업 과정에서 기획 변경에 맞춰 빠르게 구조를 바꾸고, 팀원과 소통하며 기능을 정리하는 **유연성**을 얻었음.
 
- 프로젝트 전반을 통찰하며, **각 직군에 필요한 것이 무엇인지 파악하고 이를 어떻게 설명·전달해야 이해와 업무 진행이 쉬운지**를 고민하고 실천했음. 이 과정을 통해 **협업 능력과 커뮤니케이션 스킬**을 더욱 성장시킬 수 있었음.
 
- 결과적으로 “기능 구현”을 넘어 **게임의 완성도와 플레이 경험을 고려한 개발자 관점**을 배우게 되었음.

<br/><br/>

## 💻 코드 샘플

- 담당했던 시스템 중 핵심 부분의 코드를 선별하여 zip 파일에 담았습니다!

// 코드 링크 넣기
