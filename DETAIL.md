# 🗺️ 문다인 포트폴리오
>   <b>Unity, C#</b>을 이용한 게임, 프로그램, 모바일 앱 개발의 경험이 있습니다. <br>일상에서도 항상 개발에 대한 <b>아이디어</b>를 떠올립니다. <br>어떤 일이든 <b>효율적인 방법을 끊임없이 모색하고 자동화</b>하는 것에 관심이 있습니다. <br><br>팀 프로젝트를 진행할 때는 <b>타인의 코드에 대한 이해가 빠른 편</b>이며, 소통할 때 <b>상대의 의도를 잘 파악</b>합니다. <br><b>책임감</b>이 있어, 한 번 시작한 일은 끝까지 몰두합니다.
 <br><br> 유저가 사용하기 편하고, 설명을 꼼꼼하게 읽지 않아도 사용법을 금방 익힐 수 있는 인터페이스를 중시합니다. <br><b>누구나 쉽게 다가갈 수 있는</b> 게임을 만드는 것이 목표입니다.
<br/>
<br>

## 목차

<table>
  <tbody>
    <tr>
      <td>
       <a>
        
 🍴 [쿡앤몬스터: 할머니의 레시피](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#%EF%B8%8F-%EB%AC%B8%EB%8B%A4%EC%9D%B8-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4) <br>
 > 🧩 [게임 개요](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#-%EA%B2%8C%EC%9E%84-%EA%B0%9C%EC%9A%94) <br>
 ✏️ [아쉬웠던 점과 회고](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#%EF%B8%8F-%EC%95%84%EC%89%AC%EC%9B%A0%EB%8D%98-%EC%A0%90%EA%B3%BC-%ED%9A%8C%EA%B3%A0) <br>
  ✅ [프로젝트에서 얻은 것](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-%EC%96%BB%EC%9D%80-%EA%B2%83) <br>
  🔨 [주요 개발 역할](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#-%EC%A3%BC%EC%9A%94-%EA%B0%9C%EB%B0%9C-%EC%97%AD%ED%95%A0) <br>
  🛠️ [문제 해결 경험](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#%EF%B8%8F-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EA%B2%BD%ED%97%98) <br>
  💻 [코드 샘플](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#-%EC%BD%94%EB%93%9C-%EC%83%98%ED%94%8C)
       </a>
      </td>
      <td>
      <a>
 🏭 [Silo Manager](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#%EF%B8%8F-%EB%AC%B8%EB%8B%A4%EC%9D%B8-%ED%8F%AC%ED%8A%B8%ED%8F%B4%EB%A6%AC%EC%98%A4) <br>
 
> 🕒 [개발 및 운영](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#-%EA%B2%8C%EC%9E%84-%EA%B0%9C%EC%9A%94) <br>
📌 [느낀 점](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#%EF%B8%8F-%EC%95%84%EC%89%AC%EC%9B%A0%EB%8D%98-%EC%A0%90%EA%B3%BC-%ED%9A%8C%EA%B3%A0) <br>
 💡 [핵심 구현 및 문제 해결](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-%EC%96%BB%EC%9D%80-%EA%B2%83) <br>
 💻 [코드 샘플](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/blob/main/DETAIL.md#-%EC%BD%94%EB%93%9C-%EC%83%98%ED%94%8C)
      </a>
      </td>
    </tr>
  </tbody>
</table>

<br/>
<br>

# 🍴 쿡앤몬스터: 할머니의 레시피

이븐아이 게임톤 (2025.07.14 ~) 참가작 

<br>

<img align='right' width="280" height="350" alt="Image" src="https://github.com/user-attachments/assets/a389c605-a18d-401a-b6d8-effd858e0bee" />

- **소개 영상** : [쿡앤몬스터: 할머니의 레시피](https://youtu.be/igJZ_s38T8w?si=ljie3Aei8k3IiXmC)
<br>

- **장르** : 요리 + 전투 + 경영 시뮬레이션

- **개발 기간** : 2025.07.28 ~ 진행 중 

- **개발 인원** : 8명 (기획 3, 사업PM 1, 개발PM 1, 프로그래머 2, QA 1) - <ins>프로그래머</ins>로 참여

- **플랫폼** : Android (Google Play 비공개 테스트 중)

- **개발 환경**

  - **언어** : C#
  - **엔진** : Unity
  - **서버** : 뒤끝
  - **앱 실행 및 디버깅 툴** : Android Studio, BlueStacks & adb logcat

    <br/><br/>
    
# 🧩 게임 개요
## 📝 게임 소개

`쿡앤몬스터 : 할머니의 레시피`는 **전투로 재료를 수집하고, <br>요리를 제작하여 손님에게 판매하는 과정을 반복하며 성장하는 경영 시뮬레이션 게임**입니다.<br>
플레이어는 요리로 얻은 수익과 레시피 해금으로 **점차 확장된 메뉴와 전략**을 펼치게 되며, <br>전투/경영/수집 요소가 결합된 **하이브리드 플레이**를 목표로 합니다.

<br>

## 📖 스토리

지구의 작은 도시에서 레스토랑을 운영하던 요리사 **프티**.<br> 
그녀의 보물은 할머니가 남긴 낡은 레시피북이었습니다.<br> 
어느 날, 퇴근길에 하늘에서 내려온 빛 속에서 외계인 **제피르**가 나타나 전합니다.<br> 

“다크 스파이스라는 물질이 은하 전역에 퍼지면서 모든 음식 재료들이 몬스터로 변해버렸습니다.<br> 
하지만 당신의 할머니가 남긴 특별한 능력과 레시피북이 이 저주를 풀 수 있는 유일한 열쇠일지도 모릅니다!”<br> 

이에 프티는 행성마다 저주받은 재료 몬스터를 쓰러뜨리고, 특별한 요리로 저주를 해제하며 **은하계의 평화를 되찾기 위한 여정**을 시작합니다.<br> 

<br>

## 🎯 핵심 특징

- **전투와 요리의 결합**: 몬스터를 쓰러뜨려 재료를 수집하고, 조리도구를 사용해 다양한 요리를 제작합니다.
- **손님 시스템**: 손님의 주문에 따라 요리를 판매하고 보상을 얻으며 성장합니다.
- **순환 구조**: 전투 → 재료 획득 → 요리 제작 → 판매 → 성장으로 이어지는 플레이 루프를 형성합니다.
- **전략적 확장**: 레시피 해금과 선택을 통해 점차 메뉴를 넓히고, 플레이 스타일을 다양하게 발전시킬 수 있습니다.

<br/><br/>

# ✏️ 아쉬웠던 점과 회고

### 1. 프로젝트 정리와 효율화 부족<br>
개발 기간이 짧아 콘텐츠를 크게 확장하지 못한 점도 아쉽지만,<br>
**코드와 프로젝트 전반을 정리하거나 효율적인 방식을 깊게 고민할 시간이 부족했음**.<br>
다음 프로젝트에서는 구현 뿐만 아니라 구조를 정돈하는 시간을 반드시 고려해야겠다고 느꼈음.

<br>

### 2. 구조 설계의 유연성 부족<br>
처음 코드를 작성할 때는 **효율성**을 먼저 고려했음.<br>
하지만 프로젝트를 진행하며 기획 변경(예: 수동 판매 → 자동 판매)으로 인해 구조를 여러 번 바꾸어야 했음.<br>
기획 변경이 잦을 수도 있다는 점을 경험하면서 <br>
효율성 못지않게 **확장성과 변경 가능성을 우선 고려**해야 한다는 교훈을 얻었음.<br>
**처음부터 조금 더 효율적인 코드와 변화에 유연하게 대응할 수 있는 구조 중 고민했을 때**<br>
**후자로 설계했다면 수정 부담이 줄었을 것**이라는 점을 깨달았음.<br>

이를 통해 “처음 설계 시점에서 얼마나 확장성과 변경 가능성을 고려할 수 있는가”의 중요성을 배웠음.<br>
이후에는 구조를 설계할 때 **변화에 대응할 수 있는 여지**를 남겨두는 방향으로 접근하게 되었음.

<br>

### 3. 기초 요소에 대한 사전 고려 부족<br>
UI 반응형 대응이나 콜라이더 충돌 처리처럼 기본적이지만 게임 플레이에 직결되는 문제들을 겪으면서, <br>
**초기 설계 단계에서 기초 요소를 충분히 고려하는 것의 중요성**을 체감했음. <br>

또한 저장 데이터 구조, 이벤트 전달 방식, 오브젝트 풀링 정책 등 <br>
프로젝트의 근간을 이루는 시스템 설계를 초기에 더 깊게 고민했다면, <br>
전체 개발 과정이 훨씬 안정적이었을 것이라는 아쉬움이 있었음. <br>

이를 통해 앞으로는 단순히 눈에 보이는 기능 구현뿐만 아니라, <br>
**프로젝트 전체의 안정성과 지속 가능성을 뒷받침하는 기초 설계**를 더 중점적으로 다뤄야겠다고 생각함.

<br/><br/>

# ✅ 프로젝트에서 얻은 것

- Unity와 C#을 활용해 **요리 제작 → 판매 → 성장**으로 이어지는 게임 루프 전체를 직접 구현하면서, **핵심 플레이를 책임질 수 있는 역량**을 키웠음.
  
- 충돌 판정, 이벤트 전달, 오브젝트 관리 등에서 발생한 문제들을 직접 분석하고 해결책을 코드로 구현하는 경험을 할 수 있었음.

- UI 반응형 대응, 인벤토리 관리, 데이터 자동화 등 **실제 서비스에 필요한 기술적 요소**를 학습하고 적용했음.
 
- 협업 과정에서 기획 변경에 맞춰 빠르게 구조를 바꾸고, 팀원과 소통하며 기능을 정리하는 **유연성**을 얻었음.
 
- 프로젝트 전반을 통찰하며, **각 직군에 필요한 것이 무엇인지 파악하고 이를 어떻게 설명·전달해야 이해와 업무 진행이 쉬운지**를 고민하고 실천했음. <br> 이 과정을 통해 **협업 능력과 커뮤니케이션 스킬**을 더욱 성장시킬 수 있었음.
 
- 결과적으로 '기능 구현'을 넘어 **게임의 완성도와 플레이 경험을 고려한 개발자 관점**을 배우게 되었음.


<br/><br/>

# 🔨 주요 개발 역할

## 🧑🏻‍🍳 요리 시스템 구현

### 🎓 튜토리얼 UI 및 상호작용

- 신규 플레이어가 게임의 핵심 루프를 쉽게 이해할 수 있도록 **튜토리얼 UI**를 제작했음.
- 기본 조작(이동·상호작용) → 재료 획득 → 요리 제작 → 손님 판매 순으로 **직관적인 안내 흐름**을 제공했음.
- 그 외 재료를 수급할 수 있는 전투 위치 및 체력 회복 방법 등을 적절한 타이밍에 안내함.
- 단순 텍스트 설명이 아니라 **상호작용 기반 단계 진행**으로 구성해 몰입감을 높였음.

<br>

### 🎒 재료 관리 및 인벤토리

- 플레이어가 재료를 획득하면 **인벤토리에 자동 저장**되도록 했음.
- 인벤토리는 **아이콘 + 개수**로 표시되며, 동일 재료는 **슬롯 병합**했음.
- **가방 버튼**으로 인벤토리를 **접었다/펼쳤다** 할 수 있게 했고, 
창이 열려 있어도 **실시간 반영**되도록 했음(획득·소비 즉시 업데이트).

<br>

### 📖 레시피 가능 여부 표시

- 재료를 얻을 때마다 **보유 재료로 제작 가능한 레시피**를 판별해 **가능/불가 상태**를 표시했음.
- 제작 가능할 경우에는 **현재 보유 재료로 레시피 당 몇 개까지 제작 가능한지도 함께 표시**했음.
- 인벤토리·레시피 UI 양쪽에서 상태가 **동기화**되도록 이벤트로 연결했음.

<br>

### 🍳 조리대/도구 상호작용 & 제작 흐름

- 특정 **조리도구**(예: 프라이팬, 냄비 등)에 다가가면 **요리 선택창**이 뜨도록 했음.
- 요리 선택창에는 **해당 도구로 만들 수 있는 레시피만 필터링**해 노출했음.
- 레시피 버튼을 누르면 **확인 창**에 **요리 이름 + 필요 재료 목록**을 표시함.
    - **재료 부족**이면 즉시 **부족 메시지**를 노출하고 취소됨.
    - **재료 충분**이면 제작이 시작되며, 필요한 재료가 **즉시 차감**됨.

- 제작이 완료되면 **완료 표시**(게이지 바 색 변경/완성 레시피 말풍선)가 뜨도록 했음.
- 플레이어는 완료 표시를 확인하고 **완성된 요리를 수령**할 수 있음(중복 수령 방지 처리 포함).

<br>

### 🛠️ 준비 단계 레시피 관련 구현

- **레시피 구매 및 해금 기능**
    - 스테이지 시작 전, 현재 보유한 레시피 목록을 UI로 확인할 수 있음.
    - 챕터마다 해금 가능한 레시피가 열리며, 열릴 때마다 안내 메시지가 뜨도록 함
    - 해금된 레시피(판매가격 순) → 해금 가능한 레시피(구매가격 순) 순으로 정렬해서 보여주며, 투명도를 조절하여 해금 여부를 알 수 있도록 함.
    - 레시피마다 세부 정보를 볼 수 있고, 해금되지 않은 레시피는 구매를 통해 해금할 수 있도록 구현함
      
- **레시피 선택(메뉴판) 기능**
    - 다음 스테이지에서 사용할 **레시피 3개를 선택**할 수 있음.
    - 선택한 레시피에 따라 해당 요리에 필요한 재료를 드롭하는 **몬스터만 등장**하도록 구현함.

<br>

### 🍽️ 작업대 상호작용 확장

- 모든 작업대에서 **음식을 올려놓거나 들 수 있는 기능**을 구현했음.
- 불필요하거나 잘못 올린 음식은 **쓰레기통에 버릴 수 있는 기능**을 추가해 
인벤토리·작업대 정리가 가능하도록 했음.

<br>

### 💰 판매 및 자동화 전환

- **해당 요리를 주문한 손님이 있는 판매대 접촉 시 자동 판매**되도록 구현함(TriggerManager 기반 이벤트 처리로 누락/중복 방지).
    - 초기에는 플레이어가 요리를 들고 **손님에게 가서 인터렉션 버튼을 눌러야** 판매되도록 했으나 이후 기획 변경에 맞춰 확장
      
- 판매 시 **가격·보상**이 즉시 반영되고, 손님은 음식 수령 후 **퇴장**하도록 했음.

<br>

### 🖼️ UI 연동 및 가시성

- 손님 근접 시 **요청 레시피 정보**가 표시되도록 했음(현재 목표를 직관적으로 제시).
- 인벤토리 변화, 조리 진행/완료, 판매 결과가 **이벤트 기반으로 UI에 즉시 갱신**되도록 했음.
- 버튼 내부 구성(텍스트·아이콘·가격)은 **가변 길이**에 맞춰 자동 정렬되도록 했음.

<br>

### 🔧 확장성 고려

- 제작/판매/손님 시스템을 **이벤트 중심 구조**로 연결해,  
  추후 **정비(레시피 구매·선택)**, **스토리/튜토리얼** 등 기능이 계속 추가되어도 쉽게 연동 가능하게 했음.

<br/><br/>

## 🙋 손님 시스템 구현

### 🚶 스폰 & 동선 관리

- **대기열 최대 4명** 기준으로 손님을 관리했음.
- 시작은 **랜덤 자리 배치**로 스폰하고, 이후에는 **빈자리를 우선 채우는 방식**으로 유지했음.
- 손님이 퇴장하면 해당 자리로 **다음 손님을 즉시 이동/스폰**하도록 했음.
- 경로는 **StartPoint → DoorPoint(문 앞) → CounterPoint(수령 지점) → ExitPoint** 순으로 단순화했음.

<br>

### 🧠 상태 관리

- 손님은 `대기 → 주문 표시 → 판매/수령 → 퇴장` 단계를 거침.
- 각 단계 전환 시 이벤트를 발행해 요리 시스템 및 전체 UI와 연결되도록 했음.

<br>

### 🧾 주문 생성 & 표시

- 스폰 시 **요청 레시피**를 부여했고, 플레이어가 근접하면 **주문 UI가 표시**되도록 했음.
- 주문 정보는 **레시피 이름 + 필요 재료 + 가격**으로 묶어 UI에 노출했음.
- 요리 <b>등급(일반·고급·전설)</b>에 따라 주문 확률을 다르게 설정했음.
- 또한 메뉴판 구성 시 일반 등급은 반드시 하나 이상 포함, 고급·전설 등급은 각각 하나만 선택 가능 등의 제약을 두었음.
- 플레이어가 선택한 메뉴판 구성에 따라 주문 확률이 계산되어, 실제 손님 주문에 반영되도록 구현했음.

<br>

### ⚡ 자동 판매 연동

- 플레이어가 완성 음식을 들고 손님과 접촉하면 **즉시 판매 처리**가 되도록 했음.
- 음식이 없거나 다른 음식을 들고 있을 경우 **아무 일도 일어나지 않음**.
- 같은 음식을 들고 접촉했을 때만 판매가 일어나고, 손님은 음식을 받고 퇴장함.
- 즉, 급할 땐 플레이어가 **음식을 들고 손님에게 부딪히기만 해도 판매가 이뤄지는 구조**로 설계했음.

<br>

### ♻️ 풀링 & 성능

- 손님 프리팹을 **오브젝트 풀링**으로 관리해 Instantiate/Destroy 사용을 줄였음.
- 스폰 시 **외형을 랜덤화**해 반복감을 줄였음.

<br>

### 🖼️ UI 연동

- 손님 수, 대기열, 주문 정보가 **이벤트 기반으로 UI에 반영**되도록 했음.
- 판매가 일어나면 보상 값이 즉시 갱신되어 게임 전체 루프가 이어지도록 했음.

<br><br/>

## 🎨 화면 및 리소스 구성

### 🖼️ UI

- 화면을 **Top Bar / Bottom Bar / Right Area** 등 영역별로 나눠 UI를 제작했음.
- **반응형 UI**를 적용해 다양한 기기 해상도와 비율에서도 레이아웃이 깨지지 않도록 했음.
- 기기별 **Safe Area**(노치, 하단 제스처 바 등)를 고려해 UI가 잘리지 않도록 보정했음.
- 버튼 내부에 `[레시피 구매] [코인 아이콘] [가격]`처럼 **가변 텍스트와 아이콘이 함께 들어가는 경우**에도 <br>
  정렬이 어긋나지 않도록 `LayoutGroup`과 `ContentSizeFitter`를 조합해 구현했음.
- UI가 다른 영역을 침범하는 경우에는 **스케일과 위치를 조정**해 안정적으로 표시되도록 했음.
- 스토리의 경우 몰입도를 높이기 위해 컷신·대화 UI가 모든 기기에서 적절하게 배치되도록 반응형 UI로 작업함

<br>

### 🗺️ 타일맵

- **기지 맵과 전투 맵**을 타일맵으로 구성했음.
- PPU와 스프라이트 크기가 서로 다른 에셋을 통일해 배치했고, **충돌 범위**도 함께 조정했음.
- 타일맵을 <b>레이어(배경/장식/충돌/상호작용 등)</b>로 나눠 관리했으며, <br>
  레이어별 활성화/비활성화, 간단한 애니메이션(해당 타일 레이어 기준), 상호작용 부여를 적용했음.

<br>

### 🐾 에셋 가공

- 상업용으로 구매한 몬스터 에셋들이 **크기·피벗·여백**이 제각각이라, 충돌 범위가 들쭉날쭉했음.
- **스프라이트 에디터**에서 프레임별 윤곽선을 직접 따서 **정확한 Physics Shape**을 만들었음.
- 이후, 콜라이더 크기를 자동으로 보정하기 위해 **콜라이더 축소 스크립트**를 작성했음.
    - 스크립트는 원본 Physics Shape 데이터를 불러와, 각 꼭짓점 좌표를 일정 비율 안쪽으로 이동시켜 **실루엣보다 살짝 작은 콜라이더**를 생성함.
    - 이로써 몬스터 외형의 빈 공간이나 미세한 투명 픽셀 때문에 생기던 **헛충돌 문제**를 줄였음.
- 애니메이션 전환 시 프레임마다 저장된 콜라이더 데이터를 불러와 적용해, **프레임 간 충돌 경계 불일치 문제**를 해결했음.

<br/><br/>

## 🗂 데이터 관리 자동화 적용

### 📥 외부 툴 도입

- 원본 데이터는 **엑셀**로 관리했음.
- 외부 툴을 통해 엑셀 데이터를 → **JSON 변환**, **enum 스크립트**, **로더 스크립트**까지 자동 생성되도록 했음.
- 이 과정에서 직접 JSON을 만들거나 코드를 수정할 필요 없이, **툴 실행만으로 자동 반영**되게 했음.

<br>

### 🔗 프로젝트 워크플로 연결

- 변환된 JSON과 코드 파일이 **유니티 프로젝트에 즉시 반영**되도록 폴더 구조와 경로를 정리했음.
- '엑셀 수정 → 툴 실행 → 유니티 반영' 절차를 표준화해 **팀원 누구나 같은 방식으로 사용할 수 있게** 했음.

<br>

### 📘 안정화

- 경로 오류, 데이터 누락 같은 문제를 미리 점검하고, <br>
직접적으로 데이터를 수정하지 못하도록 셀을 보호하여 권한을 관리함
- 데이터 수정 시 바로 공유하여 데이터 동기화 문제가 발생하지 않도록 조치함.
- **사용법을 화면 공유를 통해 설명**하여 안정성 있게 사용하도록 했음.

<br>

### ✅ 결과

- 데이터 변경 시 수동 반영 과정이 사라져 **작업 효율이 크게 올라갔음**.
- JSON·코드 자동화로 **오타, 형식 오류, 누락**이 줄어들어 안정성이 확보됨.
- 기획 변경(레시피 추가/수정)에도 **데이터와 코드가 항상 동기화**되도록 유지할 수 있었음.

<br><br/>

## 📱 플랫폼 및 서비스 연동

### 🗂️ 구글 플레이 콘솔 관리 (비공개 테스트 중, 프로덕션 신청 예정)

<img align='right' width="225" height="334" alt="Image" src="https://github.com/user-attachments/assets/524c41a3-4d99-4a83-ac97-c15161a0b1dd" />

- 구글 플레이 콘솔에 앱을 등록하고 키스토어 관리 및 릴리즈 빌드 업로드를 진행했음.
- **비공개 테스트 트랙을 생성**해 약 20명의 소규모 유저 그룹을 대상으로 테스트를 진행 중임.
- 비공개 테스터 대상 안내사항, 이슈, FAQ, 업데이트 내역 등을 공유하는 노션 데이터베이스를 관리함.<br>
  - [비공개 테스터 용 노션 데이터베이스](https://mdls.notion.site/264b160f36da80edbd7dec1b1dab0925?v=264b160f36da80569029000cba791bcf&source=copy_link)
- 구글 플레이 스토어를 통해 게임을 다운로드하도록 하여 실제 플레이 환경에서 피드백을 수집하고 있으며,<br>
  출시 노트도 직접 작성하여 관리함.
- 비공개 의견을 받아 개선 사항을 정리했고, 의견 답변 관리까지 직접 맡았음.
- 버전 코드/버전 네임 관리, 기기 호환성 설정, 앱 서명 등 **배포 과정 전반을 경험**했음.

<br>

### ☁️ 뒤끝 서버 연동 (마무리 단계, 테스트 진행 중)

- 뒤끝 SDK를 활용해 구글 로그인 기반 계정 연동을 구현했음.
- 로그인 성공 시 발급되는 유저 고유 ID를 기반으로, 유저 데이터를 서버에 저장/불러올 수 있도록 했음.
- 튜토리얼 진행 여부, 안내 메시지 확인 여부 등을 JSON으로 저장해, <br>
나중에 새로운 메시지가 추가되더라도 유저가 놓치지 않고 확인할 수 있도록 관리했음.
- 현재는 인앱 결제 연동 및 스테이지 관련 유저 데이터 관리 기능을 추가 개발 중임.

<br>

### 📺 애드몹 광고 연동 (기본 연동 완료, 인게임 적용 진행 중)

- 리워드형 광고와 전면 광고를 프로젝트에 연결해 테스트 환경에서 정상적으로 동작하도록 세팅했음.
- 인게임 흐름에 자연스럽게 연결하는 단계는 진행 중임.
- 테스트 환경과 실제 서비스 환경을 구분해 QA 단계에서 안전하게 검증할 수 있도록 설정했음.

<br><br/>

## 🔮 추후 개발 예정 기능

### 🏪 상점 시스템 구현 (+ 광고 및 인앱 결제 구현)

- 게임 내 재화·아이템 구매가 가능한 상점 시스템을 구축할 예정임.
- Google Play 결제 및 보상형 광고를 연동해 실제 서비스 환경에서 동작 가능하게 확장할 예정임.

<br/><br/>

# 🛠️ 문제 해결 경험

## 🍳 자동 판매 전환에 따른 트리거·이벤트 동기화 문제

### ⚙️ **문제 상황**

초기엔 `OnTriggerEnter/Exit` + **인터랙션 버튼**을 눌러야만 동작하도록 했음. <br>
기획이 <b>접촉 즉시 판매(자동 판매)</b>로 바뀌면서, 접촉 시점마다 **필요 정보 조회/처리**가 일어나야 했고, <br>
가격·재고 등 **변동 정보가 화면에도 바로 보여**야 했음. <br>
기존 구조에선 버튼 전제 로직 때문에 처리 타이밍이 어긋나거나 누락되는 문제가 있었음. <br>

<br>

### 🧩 **원인 분석**

- 트리거 콜백 안에서 바로 업무 로직을 처리해 **물리 이벤트와 도메인 로직이 뒤섞였음**.
- 버튼 입력을 전제로 짰던 흐름이라 **접촉만으로 처리해야 할 시나리오가 누락**되었음.
- 접촉 중 값을 갱신하려고 매 프레임 확인할 경우 게임이 너무 무거워지거나 **중복 호출**이 생길 수 있었음.

<br>

### 🛠️ **해결 방법**

- **구조 분리**: `TriggerManager – PlaceTrigger – TriggerZone – Listener`로 역할을 분리했음. <br>
    - **TriggerZone**: 물리 이벤트만 감지(`Enter/Exit`). 처리 로직 없음.
    - **TriggerManager**: 현재 **접촉 중인 대상 목록**을 관리하고, 이벤트를 **한 곳에서** 발행함.
    - **PlaceTrigger**: 해당 지점의 메타정보(종류/ID/게이지 등)를 보관하고, **값이 바뀔 때만** OnChanged 이벤트를 쏘게 했음.
    - **Listener(UI/시스템)**: 매 프레임 확인 없이 **구독 방식**으로 갱신을 받아 화면·로직에 반영했음.
      
- **처리 흐름 단순화**
    1. `Enter` 시점에 자동 판매가 필요한 트리거면 **즉시 1회 처리**했음.
    2. 접촉이 유지되는 동안 가격/재고가 **실제로 변경될 때에만** PlaceTrigger가 이벤트를 발행했고, UI가 이를 받아 **표시만 갱신**했음.
    3. `Exit` 시점에는 목록에서 제거하여 이후 이벤트가 가지 않도록 했음.

<br>

### 🔁 **결과**

- 자동 판매로 바뀐 뒤에도 **중복 실행/누락 없이** 안정적으로 처리됨.
- UI는 **값이 실제로 바뀔 때만** 갱신되어 보기 자연스러워졌음.
- 물리 감지(TriggerZone)와 업무 처리(TriggerManager/PlaceTrigger/Listener)가 분리되어 **읽기·확장·디버깅이 쉬워졌음**.

<br/><br/>

## 📱 반응형 UI 배치 및 Stretch 적용 문제

### ⚙️ **문제 상황**

- 다양한 기기 해상도(16:9, 19.5:9, 태블릿, Z Fold 등)에서 UI를 테스트했을 때, <br>

    - **같은 그룹에 붙어 있어야 할 버튼들이 기기 너비 변화에 따라 따로따로 떨어져 보이는 현상**이 발생했음.
    - 예를 들어, 조이스틱과 푸시 버튼처럼 항상 같이 붙어 있어야 하는 묶음이 화면 비율에 따라 서로 간격이 달라져 UI가 어색하게 배치되었음.

<br>

### 🧩 **원인 분석**

- 노치, 하단바 같은 **SafeArea는 고려해서 보정**했음.
- 하지만 전체 화면에 **Stretch를 일괄 적용해 위치를 맞추는 방식**만 사용하다 보니, <br>
    - 기기 너비가 변할 때 **UI 요소 간 상대적인 간격 유지**를 적용하지 못했음.
    - 그 결과, 같이 붙어 있어야 하는 버튼들이 함께 관리되지 않는 문제가 발생했음.

<br>

### 🛠️ **해결 방법**

1. **UI 영역 구분**
    - 화면을 **Top Bar / Bottom Bar / Right Area** 등으로 나누어 그룹 단위로 정렬을 유지하도록 함.
    - 각 영역 안에서만 Stretch를 적용하고, 영역 간에는 상호 침범하지 않도록 함.
      
2. **LayoutGroup 활용**
    - 버튼이나 텍스트+아이콘 같은 묶음은 `Horizontal/Vertical LayoutGroup`으로 관리해, <br>
    기기 너비가 변해도 **항상 일정한 간격과 정렬**을 유지하도록 했음.
        
3. **버튼 내부 정렬 개선**
    - `[레시피 구매] [코인 아이콘] [가격 텍스트]` 같은 UI는 `ContentSizeFitter`와 `LayoutGroup`을 조합해, <br>
    가격 길이가 달라져도 **정렬이 깨지지 않게 자동 보정**되도록 구현했음.

      
<br>

### 🔁 **결과**

- 다양한 화면 비율·해상도에서 UI 간격과 묶음이 안정적으로 유지됨.
- SafeArea 고려 + Stretch 조정의 한계를 보완해 **가독성과 일관성**이 확보됨.
- 영역 단위로 UI를 관리하게 되어 **추가 화면 제작 속도도 향상**됨.

  
<br/><br/>

## 🐾 몬스터 에셋 가공(콜라이더 정합) 문제

### ⚙️ **문제 상황**

- 상업용 에셋을 여러 곳에서 구매하여, 에셋마다 **픽셀 크기·비율·피벗 기준**이 제각각이라, <br>
같은 월드 스케일에서 **콜라이더가 너무 크거나 작게 맞는 문제**가 발생했음.
- 애니메이션 전환 시 프레임마다 외형이 달라 **충돌 경계가 들쭉날쭉**해 보이는 현상도 있었음.

<br>

### 🧩 **원인 분석**

- 에셋 제공처별로 **PPU, Pivot, Trim 여부**가 달라 물리 경계가 통일되지 않았음.
- 자동 생성(Box/Auto) 콜라이더는 투명 여백과 비정형 윤곽을 제대로 반영하지 못해 **빈 공간까지 충돌**하는 경우가 있었음.
- 애니메이션 클립이 프레임마다 실루엣이 달라지는데, **정적 콜라이더**만 사용하면 프레임 간 오차가 누적됐음.

<br>

### 🛠️ **해결 방법**

1. **가져오기 표준화**
    - 몬스터류 공통 **PPU(예: 세로 기준 통일)**, <b>Pivot 규칙(바닥 중앙)</b>을 정해 일괄 적용했음.
    - 불필요한 여백 제거(Trim) 규칙을 정해 시각/물리 기준을 맞췄음.
      
2. **스프라이트 에디터 기반 윤곽 추출**
    - Sprite Editor에서 모든 프레임의 **Outline/Physics Shape**를 직접 따서, **실루엣에 맞는 폴리곤**을 확보했음.
    - 프레임별 물리 경계를 에셋에 저장해 애니메이션 전환 시 **정확한 충돌 모양**을 사용하도록 했음.
      
3. **콜라이더 인셋(안쪽 수축) 적용**
    - 추출한 폴리곤을 **일정 마진만큼 안쪽으로 축소**하는 로직을 적용했음(가시 영역보다 살짝 작은 충돌 경계).
    - 결과적으로 가장자리 픽셀의 미세 요철/투명 픽셀로 인한 **헛충돌을 방지**했음.
      
4. **런타임 동기화**
    - 스프라이트가 프레임 전환될 때 해당 프레임의 **저장된 폴리곤**을 불러와 콜라이더에 즉시 반영하도록 했음.
    - 필요 시만 갱신(스프라이트 변경 시)하여 **성능 부담 최소화**했음.

<br>

### 🔁 **결과**

- 서로 다른 출처의 에셋이라도 **통일된 PPU·Pivot·Trim 규칙**으로 크기/충돌감이 일관되게 맞춰졌음.
- 실루엣 기반 폴리곤 + 인셋 적용으로 **빈 공간 판정·과충돌이 사라짐**.
- 애니메이션 전환 시에도 프레임별 충돌이 **자연스럽게 이어져** 타격감·피격감이 안정됨.

<br/><br/>

## 🚧 기지–전투 맵 바리게이트 문제

### ⚙️ **문제 상황**

- 기지와 전투 맵 사이의 바리게이트는 <br>
    - 플레이어가 **접시를 들고 있을 때는 밖으로 못 나가게** 하고,
    - 몬스터는 **기지 안으로 못 들어오게** 막아야 했음.
      
- 처음에는 하나의 콜라이더에서 `isTrigger` 값을 켜고 끄는 방식으로 구현했는데, <br>
    - 트리거가 불안정하게 동작해 이벤트가 누락되거나,
    - 통과하면 안 되는 경우에도 그냥 지나가는 문제가 발생했음.

<br>

### 🧩 **원인 분석**

- 트리거와 벽 역할을 한 오브젝트에서 동시에 처리하려다 보니 **충돌 판정이 꼬임**.
- `isTrigger`를 켜고 끄는 방식은 상황에 따라 이벤트가 중복되거나 사라질 수 있었음.

<br>

### 🛠️ **해결 방법**

1. **센서와 벽을 역할 분리**
    - 센서는 항상 Trigger 상태로 두고, **플레이어나 몬스터가 접촉했는지 감지만** 하도록 함.
    - 벽은 실제 충돌을 담당하도록 분리했음.
      
2. **조건에 따라 충돌 무시 처리**
    - 플레이어가 접시를 들고 있을 때만 **플레이어와 벽의 충돌을 유지**하도록 함.
    - 접시를 들고 있지 않으면 `IgnoreCollision`을 사용해 **플레이어와 벽의 충돌을 무시**하도록 변경.
    - 몬스터는 항상 벽과 충돌을 유지하도록 해 기지에 들어오지 못하게 했음.

<br>

### 🔁 **결과**

- 접시를 들고 있으면 **기지 밖으로 나갈 수 없고**, 접시가 없을 때만 **자유롭게 이동 가능**해짐.
- 몬스터는 언제나 기지 안으로 들어오지 못하도록 안정적으로 차단됨.
- `isTrigger`를 토글하던 방식 대신, **충돌 무시 설정을 조건부로 적용**해 동작이 단순해지고 안정성이 확보됨.


<br/><br/>


# 💻 코드 샘플

> 담당했던 시스템 중 핵심 부분의 코드를 선별하여 담았습니다!

[쿡앤몬스터: 할머니의 레시피 샘플 코드](https://github.com/Mekdlsdl/Game-Client-Programmer-Portfolio/tree/main/%EC%83%98%ED%94%8C%20%EC%BD%94%EB%93%9C/%EC%BF%A1%EC%95%A4%EB%AA%AC%EC%8A%A4%ED%84%B0_%ED%95%A0%EB%A8%B8%EB%8B%88%EC%9D%98%20%EB%A0%88%EC%8B%9C%ED%94%BC)


<br><br>
<br><br>


# 🏭 Silo Manager
(주) ○○사료 – 현장 사일로 관리용 어플리케이션

<br>

<img align='right' width="455" height="350" alt="Image" src="https://github.com/user-attachments/assets/db0b3fa5-b478-4370-8f46-a50b2522fe3e" />


- **실행 영상** : [Silo Manager](https://m.site.naver.com/1GQhe)

<br>

- **개발 기간** : 2024.05.04 ~ 2024.05.17 (약 2주) - 이후 유지 보수 중(2025.09 기준)

- **개발 인원** : 1인 (기획 ~ 개발 전 과정 담당)

- **개발 환경**
 
  - **언어** : C#
  - **엔진** : Unity
  - **서버** : Firebase (Realtime Database, Storage, Authentication)
  - **앱 실행 및 디버깅 툴** : Android Studio

<br/><br/>

# 🕒 개발 및 운영

해당 프로젝트는 **(주) ○○사료의 요청으로 제작된 현장 전용 앱**으로, <br>
**초기 개발은 약 2주간 진행되었으며**, 완성 이후 현재까지 **약 1년 이상 현장에서 실사용되고 있는 프로젝트**입니다. <br>
기능 개선 요청이 있을 때마다 **약 1주일 내외의 기간을 들여 유지 보수 및 업데이트를 직접 진행**하고 있습니다. <br>

<br/>

## 🧭 프로젝트 개요

- 현장에서 사일로 상태를 기록하던 기존의 수기 방식은 **용지 분실 및 작업 효율 저하** 문제가 있었음
- 담당자 요청에 따라, **여러 사람이 각자의 스마트폰으로 사진과 정보를 기록·조회할 수 있는 모바일 프로그램**을 설계
- 사일로 이름, 높이, 상태(가득/바닥 등) 및 사진 기록 기능을 제공하며,
    최근 3일간의 데이터를 조회 및 수정 가능하도록 함
    

<br/><br/>

## 🔑 주요 기능

- Firebase 익명 로그인
- 사일로 개별 정보 입력 및 수정 (이름, 높이, 상태 체크)
- 사진 촬영 또는 앨범에서 이미지 첨부 가능
- 최근 3일간의 정보 조회 및 수정 가능
- 전체 정보와 이미지를 자동으로 동기화하여 UI에 반영

<br/><br/>

# 📌 느낀 점

전체 개발을 혼자서 진행하면서 단순 기능 구현을 넘어, <br>
실 사용성과 유지보수까지 고려한 구조 설계의 중요성을 체감했습니다. <br>
**서버는 반드시 유료가 아닌, 무료 서버만 사용해달라는 요청이 있었기 때문에**, <br>
Firebase의 무료 요금제(Spark 플랜) 내에서 발생할 수 있는 제약들을 충분히 고려해야 했습니다. <br>
그 제약을 이해하고, 이를 **우회하거나 보완하는 설계 방안을 직접 고민하고 구현한 경험**은 <br>
향후 협업 환경에서도 **한정된 자원 안에서 효과적인 해결책을 도출할 수 있는 역량**으로 이어질 것이라 생각합니다.

<br/><br/>

# 💡 핵심 구현 및 문제 해결

## 🔄 자동 삭제 구현 – 서버 최적화

### ⚙️ 문제 상황

- Firebase Realtime Database와 Storage는 **무료 요금제(Spark 플랜)** 사용 시, <br>
    **동시 연결 수, 트래픽, 읽기/쓰기 속도** 등에서 제약이 있을 수 있음
- 특히 이 앱은 사용자가 매일 데이터를 입력하고, <br>
    각 사일로마다 사진도 함께 저장되기 때문에 **시간이 지날수록 데이터와 이미지가 누적됨**  
- 무료 요금제 환경에서 단순히 데이터를 계속 쌓아두는 방식은 <br>
    **불필요한 읽기/쓰기 연산을 유발하고, 속도 저하나 비용 문제로 이어질 가능성이 있었음**
- 실제 현장에서 필요로 하는 정보는 **최근 3일간의 데이터뿐**이었기에, <br>
    전체 데이터를 유지하는 것은 **비용, 성능, 유지보수 측면에서 비효율적**이었음

  <br>
  
### 🛠️ 해결 방법

- 사용자가 로그인할 때마다 자동으로 작동하는 **데이터 정리 함수**를 구현
- **최근 3일간의 데이터 및 필수 정보만 리스트로 추려 유지**하고, 나머지 오래된 데이터는 서버에서 자동 삭제
- Firebase Storage는 폴더 삭제 기능이 없어,
    - 이미지 저장 시 별도의 `storage` 키에 날짜별로 사일로 번호 리스트를 기록
    - 자동 삭제 시 해당 정보를 기반으로 **날짜별, 사일로별 이미지 경로를 역추적하여 하나씩 직접 삭제** <br>
      → 이를 통해 **Firebase 구조의 제약을 우회하면서**, <br>
        **사용자가 불필요한 데이터 삭제에 관여하지 않아도 자동으로 서버 상태가 최적화**되도록 처리함

<br/><br/>

## 🧷 **사일로 이름 수정 대응 – 데이터 무결성 유지**

### ⚙️ 문제 상황

- 기존에는 사일로 이름이 고정되어 있어 번호로만 처리했음
- 이름 수정 요청이 들어오면서 **과거 데이터와 이름 연결, 빈 이름 처리, 변경 유지**가 모두 문제로 떠오름

<br>

### 🛠️ 해결 방법

- 각 사일로 정보 내에 **`name` 키를 추가**해 이름을 별도로 저장
- 동시에 날짜에 관계없이 전체 사일로들의 이름을 관리하는 **전역 `name` 키**도 함께 생성
- 사일로 정보를 저장할 때:
    - 개별 사일로 키의 `name`도 갱신
    - 전체 `name` 키에도 해당 사일로 번호의 이름을 기록
- 이후 사일로를 조회할 때:
    - 해당 날짜의 사일로에 `name` 키가 없으면 **전체 `name` 키에서 가져오도록 처리**
- 이 방식으로 이름이 수정되어도 이전과 이후 데이터 모두 일관성 있게 처리 가능하며, **데이터 누락이나 조회 오류 없이 유연한 관리**가 가능해짐

<br/><br/>

## ☁️ 서버 참조 최소화 – 로컬 기반 데이터 흐름 설계

### ⚙️ 문제 상황

- Firebase는 서버 응답 속도나 네트워크 연결 상태에 따라 앱 성능이 영향을 받을 수 있음
- 그래서 **가능한 한 서버 접근을 줄이고, 사용자에게 빠르고 부드러운 경험을 제공**하고자 함

### 🛠️ 해결 방법

1. **로그인 시 모든 사일로 정보 + 이미지 한 번에 불러오기**
    - 메인 화면 구성을 위해 어차피 필요한 데이터이기 때문에 이 시점에 한꺼번에 로딩
    - 이미지들은 **리스트에 저장**, 이후 이미지 관련 기능은 **전부 로컬 리스트에서 동작**
      
2. **사일로 정보는 메인 화면 기준으로 로컬 유지**
    - 정보 수정 창은 메인 화면의 데이터를 바탕으로 초기화
    - 수정 후 저장하면, 정보 수정 창의 데이터를 메인화면에 바로 반영
    - 수정 내용은 그때그때 서버에도 반영되기 때문에 일관성 유지됨
      
3. **서버 참조 최소화**
    - 로그인 시 1회
    - 사용자가 **다른 날짜 데이터 조회** 버튼을 눌렀을 때만 서버 재조회
    - 나머지 작업은 **모두 로컬 상태로 동작**, 빠른 반응성과 오프라인 대응 가능

<br/><br/>

## 🖼️ 비동기 이미지 로딩 문제 해결 – UX 개선

### ⚙️ 문제 상황

- DB와 Storage를 동시에 조회했지만, Storage(이미지)의 응답이 느림
- 화면이 먼저 떠버리면서 이미지가 안 뜨거나, 이미지가 없는 에러 발생
- 사용자 입장에선 앱이 버벅이거나 오류 난 것처럼 보일 수 있음

<br>

### 🛠️ 해결 방법

- **이미지 로딩이 끝날 때까지 로딩 패널을 보여주고, 로딩 완료 후 화면 표시**
- 사용자에게는 **“정상적으로 로딩 중”이라는 피드백**을 주고, <br>
    개발 측면에서도 **비동기 로딩 타이밍 문제로 인한 에러 방지**
- 사용자는 “렉인가?” 생각하지 않고 기다릴 수 있으며, 모든 이미지가 확실히 로드됨

<br/><br/>

# 💻 코드 샘플
> 실제 기업에서 쓰이는 애플리케이션으로 보안상, 포트폴리오 용 프로젝트를 첨부합니다. <br>

[Silo Manager 샘플 코드](https://github.com/Mekdlsdl/Silo-Manager/tree/main/)

<br><br>
<br><br>

# 🎮 Code-Eat

졸업 프로젝트

<br>

<img align='right' width="435" height="255" alt="Image" src="https://github.com/user-attachments/assets/171e3977-6602-4311-97f9-dea8803e6fba" />

- **실행 영상** : [Code-Eat](https://m.site.naver.com/1GQi1)

- **게임 출시 링크** : [Code-Eat](https://wandu.itch.io/code-eat)

<br>

- **장르** : 교육용 멀티플레이 로컬 게임

- **개발 기간** : 2023.03.02 ~ 2023.06.21 (약 4개월)

- **개발 인원** : 5명 - <ins>프로그래머</ins>로 참여

- **개발 환경**

  - **언어** : C#
  - **엔진** : Unity

<br/><br/>

# 🧩 게임 개요

`Code-Eat`은 프로그래밍 개념 학습을 기반으로 한 **교육용 멀티플레이 퀴즈 액션 게임**입니다. <br>
플레이어는 알고리즘, 정렬, 트리 등 다양한 개념을 주제로 구성된 맵에서 <br>
**문제를 풀고, 정답을 맞히면 무기를 사용해 적을 처치**합니다. <br>
각 맵은 개념마다 다른 테마와 퀴즈로 구성되며, <br>
**게임패드와 키보드를 활용해 최대 5인이 함께 학습하고 협력 플레이**를 즐길 수 있습니다.

<br/><br/>

# 📌 협업 및 기여 요약

- 본 프로젝트는 팀으로 진행되었으며,
    트리 & 정렬 퀴즈 문제 유형, 정렬 알고리즘 시각화, 개념 팁 리디자인 등
    주요 교육 관련 기능을 중심으로 개발을 주도함
    
- 타인이 작성한 기능에서 발생한 UX 문제를 인지하고 개선하는 역할도 수행함으로써,
    협업 능력과 사용자 중심 사고를 동시에 증명함
    

<br/><br/>

# 🔨 주요 개발 역할

### 🧠 트리 & 정렬 퀴즈 문제 유형 구현

- 트리와 정렬 문제를 위한 추가 로직 전체 구현
- 트리 문제: 필수 노드 유지, 랜덤 트리 구조 생성 후 출제 가능 여부 판단 로직 설계
- 정렬 문제: 삽입/선택/버블 정렬의 과정별 흐름을 시각적으로 보여주는 애니메이션 구현
- 각 알고리즘의 핵심 동작 과정을 직관적으로 표현하여 학습 효과 극대화

<br>

### 📊 알고리즘 시각화 및 UX 개선

- **정렬 알고리즘(삽입, 선택, 버블), 트리 순회(전위, 중위, 후위, 레벨)** 애니메이션 구현
- 정렬 흐름을 직관적으로 보여주기 위한 요소별 움직임, 강조 효과 설계
- 크루스칼 알고리즘 애니메이션 보완 (간선 선택 순서 및 강조 효과 추가)

<br>

### 📚 개념 팁 콘텐츠 리디자인

- 복잡했던 개념 설명을 여러 페이지로 분할, 직관적이고 간결한 문장으로 재작성
- 시각 자료 및 동영상 요소 삽입을 통한 학습 효과 강화
- 맵별 평균 5개 이상의 개념 팁 콘텐츠 리디자인

<br>

### 🎮 멀티플레이 UI/UX 개선

- 개념 팁 창 확인 버튼 동기화 처리 (모든 플레이어가 눌러야 다음 단계로 진행)
- 각 플레이어의 확인 여부를 캐릭터 이모지로 표시하여 직관성 강화

<br/><br/>

# 🛠️ 문제 해결 경험

## ⏸️ 중간 단계에서 정렬 멈춤 구현

### ⚙️ **문제 상황**

정렬이 중간 단계에서 멈추어야 하는 문제에서, 정렬이 너무 일찍 끝나거나 멈추는 시점이 일정하지 않아 <br>
정답이 정확히 출력되지 않는 경우가 있었음.

<br>

### 🧩 **원인 분석**

정렬 알고리즘마다 반복 방식과 한 단계를 마무리하는 기준이 달랐기 때문에, <br>
미리 설정한 `step` 값과 실제 정렬이 멈추는 시점이 어긋나는 문제가 발생했음. <br>
특히 정렬이 조기에 완료되는 경우, 정답으로 저장된 `step` 값이 유효하지 않게 되는 문제가 있었음.

<br>

### 🛠️ **해결 방법**

- 각 정렬 알고리즘별로 ‘한 단계가 끝났는지’를 체크하는 타이밍을 각각의 로직에 맞춰 적절하게 설정함.
- 정렬이 `step` 값에 도달하기 전에 완료된 경우에는, <br>
    실제 멈춘 단계 수를 기준으로 `step` 값을 갱신하여 현재 상태에 맞는 정답이 출력되도록 처리함.
    
- **몇 단계가 진행됐는지를 맞히는 문제 유형**의 경우에는  
    한 단계가 끝날 때마다 <b>모든 접시에 크기 변화(커졌다가 작아지는 애니메이션)</b>를 부여하여,    
    플레이어가 진행 단계를 직관적으로 파악할 수 있도록 시각적 피드백을 추가함.
    
<br>

### 🔁 **결과**

모든 정렬 알고리즘에서 중간 단계 멈춤이 **정확하게 작동**하게 되었고, <br>
정렬 단계와 정답 출력의 **일관성이 확보**되었음. <br>
또한 시각적 애니메이션을 통해 단계 구분이 명확해지면서, <br>
**플레이어의 이해도와 몰입감도 함께 향상**되었음.

<br/><br/>

## 🌳 트리 구조의 랜덤 생성 및 조건 제어

### ⚙️ **문제 상황**

트리 문제에서 트리의 형태가 문제마다 매번 달라져야 했지만, 완전히 무작위로 생성하면 <br>
**정답을 만들 수 없는 구조가 나오거나 시각적으로 연결이 어색해지는 경우**가 있었음.

<br>

### 🧩 **원인 분석**

문제를 출제하기 위해 필요한 최소한의 노드 수가 있는데, <br>
이를 고려하지 않고 레벨 2의 노드를 무작위로 생성하면 조건을 충족하지 못하는 구조가 나올 수 있었음. <br>
또한 노드와 간선을 별도로 생성하면 연결이 꼬이거나 번호가 맞지 않아 시각적 오류도 발생했음.

<br>

### 🛠️ **해결 방법**

- 레벨 0과 1의 노드는 항상 생성되도록 고정하고,     
    레벨 2의 노드 4개는 **bool 리스트**로 관리하여 랜덤으로 활성화/비활성화되도록 구성함. <br>
- `0` 또는 `1`의 난수를 생성해 `true/false`로 변환해 bool 리스트에 적용했고,    
    이후 필요한 최소 노드 수를 만족하지 않으면 **다시 생성하도록 반복 처리**함. <br>
    
- 문제 출제를 위해 최소 노드 수를 미리 계산하고, 조건을 충족할 때만 구조가 완성되도록 설계함. <br>
- 시각적으로 정확히 연결되도록 **노드와 간선에 동일한 번호를 부여**하고, <br>
    활성화된 노드에 연결된 간선만 보이게 처리함.
    
- 각 노드를 **다른 종류의 랜덤 아이스크림 이미지로 표현**해 시각적으로 중복 없이 구분되도록 구성함.

<br>

### 🔁 **결과**

트리의 형태가 문제마다 다양하게 구성되면서도, 출제 조건을 항상 만족하는 구조가 안정적으로 생성됨. <br>
노드와 간선의 연결도 시각적으로 일관되게 표현되어 학습 효과와 몰입감이 높아졌고, <br>
랜덤 요소를 통해 반복 학습에서도 흥미를 유지할 수 있었음.

<br>

## 🌲 노드 기반 트리 문제 출제 로직 설계 및 예외 처리

### ⚙️ **문제 상황**

트리 문제에서 각 노드를 기준으로 부모, 형제, 자식 노드와 관련된 문제를 무작위로 출제해야 했음. <br>
하지만 트리 구조 상 존재하지 않는 관계(예: 루트 노드의 부모, 비활성화된 자식 등)를 기준으로 <br>
문제가 출제될 경우 오류가 발생하거나 정답이 복수로 나오는 문제가 있었음.

<br>

### 🧩 **원인 분석**

트리 구조는 계산이 가능한 형태지만, <br>
노드 번호가 0부터 시작되고, 트리 레벨마다 노드의 존재 여부가 달라지기 때문에 <br>
**단순 계산만으로는 유효한 문제와 정답을 보장할 수 없었음**. <br>
또한 정답 후보가 중복되거나, 문제 자체가 출제 불가능한 상태일 수 있었음.

<br>

### 🛠️ **해결 방법**

- 트리 구조를 계산하기 편하도록 노드 번호에 +1을 더해 1부터 시작하도록 변환한 뒤,   
    트리의 특성에 따라 **부모, 형제, 자식 노드를 계산식으로 판별**함 <br>
    
    - 부모 노드: `nodeNum / 2`
    - 형제 노드: `nodeNum ± 1` (짝수/홀수 여부로 판단)
    - 자식 노드: `nodeNum * 2`, `nodeNum * 2 + 1` <br>
      
- 각 노드에 대해 부모/형제/자식 문제를 출제할 수 있는 조건을 사전에 체크하고,   
    가능한 경우에만 출제가 되도록 처리함 <br>
    
    - 예: `nodeNum > 1` → 부모, 형제 문제 출제 가능 <br>
               `nodeNum < 4` → 자식 문제 출제 가능 <br>
        
- **자식 노드는 실제로 활성화된 노드인지 여부를 bool 리스트를 통해 확인**,  
    비활성화된 노드는 정답 후보에 포함되지 않도록 필터링함 <br>
    
- 각 문제마다 가능한 정답 후보를 리스트로 저장한 후, 그 중 하나를 정답으로 선정하고,   
    나머지 보기는 해당 문제와 무관한 노드들 중에서 선택해 **정답 중복을 방지**함 <br>
    
- 문제 출제 가능 여부와 정답 후보는 문제 생성 단계에서 미리 전부 검증하여,   
    **출제 자체가 불가능한 상황이나 오류 발생을 사전에 차단**함
    
<br>

### 🔁 **결과**

트리 문제에서의 **정답 오류, 출제 불가, 보기 중복** 등 다양한 예외 상황을 사전에 차단할 수 있었고, <br>
로직만으로 정확하게 구조를 계산해 문제를 출제하는 시스템을 구현함. <br>
노드 관계 기반 문제 출제의 복잡도를 낮추고, 사용자에게도 직관적인 문제 구성이 가능해졌으며, <br>
코드 상에서도 확장성과 유지보수성이 높은 구조를 완성했음.

<br/><br/>

## 🌐 트리 순회 구조 기반 문제 출제 및 애니메이션 구현

### ⚙️ **문제 상황**

트리 순회 문제에서 순회 결과를 시각적으로 잘 전달하고, <br>
동시에 트리 형태를 유지하면서 문제를 출제해야 했음. <br>
하지만 텍스트로만 결과를 보여줄 경우, <br>
트리 구조와의 연결이 약해져 사용자가 직관적으로 순회 개념을 이해하기 어려운 문제가 있었음.

<br>

### 🧩 **원인 분석**

트리 구조가 단순히 데이터로만 존재하면 순회 결과와 시각적인 트리 간의 연동이 불가능했고, <br>
순회를 애니메이션으로 보여주기 위해선 트리 구조 자체를 오브젝트로 구성하고 <br>
순서대로 처리할 수 있는 로직이 필요했음.

<br>

### 🛠️ **해결 방법**

- 트리는 이미 구현해둔 `TNode` 클래스를 활용해 구성하였고,     
    각 노드는 실제 게임 오브젝트로 만들어져 트리 구조대로 배치되도록 구성함. <br>
    - 이때 구성된 트리는 순회 알고리즘에서 직접 탐색할 수 있는 형태이며, 
        순회 로직과 시각적인 연출이 유기적으로 연결될 수 있도록 설계되어 있음. <br>
        
- 문제가 출제될 때는 전위, 중위, 후위, 레벨 순회 중 하나를 무작위로 선택해     
    해당 순서로 트리를 순회하고, 그 결과를 리스트에 저장함. <br>    
    - 이 리스트에는 각 노드 오브젝트가 그대로 담기며, 이 오브젝트들을 기반으로 순회 결과와 애니메이션을 구성함. <br>
        
- 하단에는 순회 결과를 표시하는 UI가 빈칸 이미지로 미리 세팅 되어 있고,     
    리스트에서 무작위 인덱스를 골라 **해당 위치를 빈칸으로 남긴 뒤**,     
    나머지 칸에는 해당 오브젝트의 **이미지 스프라이트를 가져와 변경해줌**. <br>    
    - 빈칸은 기본적으로 비어 있는 이미지로 구성되어 있기 때문에,        
        **이미지 변경만 생략하면 빈칸으로 자연스럽게 남게 되는 방식**임. <br>
        
- 이와 동시에, 순회 결과 리스트에 담긴 **원본 오브젝트들**을 순서대로 접근해 **투명도를 연하게 조절**함. <br>    
    - 원본 오브젝트는 **상단에 트리 모양으로 스폰되어 있음** <br>
    이로 인해 하단 순회 결과가 하나씩 등장할 때마다,     
    **트리 상단에서도 해당 노드가 시각적으로 함께 강조되는 애니메이션이 적용**됨.    
    이를 통해 사용자가 “트리 구조에서 어떤 노드가 언제 방문되었는가”를 **직관적으로 인식**할 수 있음

<br>

### 🔁 **결과**

트리 순회 과정을 그대로 따라가는 애니메이션 효과가 시각적으로 적용되면서, <br>
**순회 방식별 개념 학습 효과가 대폭 향상됨**. <br>
단순한 알고리즘 문제를 넘어서 구조적 흐름까지 체감할 수 있도록 구현해, <br>
게임의 교육적 목적과 몰입감을 동시에 충족시킬 수 있었음.

<br/><br/>

## 💻 코드 샘플

[정렬 문제 코드](https://github.com/Mekdlsdl/Code-Eat/tree/main/Assets/Scripts/ProblemMode/Sorting)

[트리 문제 코드](https://github.com/Mekdlsdl/Code-Eat/tree/main/Assets/Scripts/ProblemMode/Tree)

<br/><br/>

## 📎 관련 자료

[2023-2-융복합SW(서울)-졸업논문 - 문다인, 김민정, 김시완, 김하연, 홍주완.pdf](attachment:9afa939a-7ff1-4a47-85cd-9c9ef0935657:2023-2-융복합SW(서울)-졸업논문_-_문다인_김민정_김시완_김하연_홍주완.pdf)

[b1 설계서.pdf](attachment:9de5fc72-031f-44cb-8aa7-7ebd10e8dee8:b1_설계서_최종.pdf)

[b1 최종발표.ppsx](attachment:73e9ca5e-a2aa-40ad-8e06-1ba0127100de:b1_최종발표_수정_5.ppsx)

[b1 최종발표.pdf](attachment:d659db50-3210-4623-83b1-a363a086279c:b1_최종발표_최종.pdf)
